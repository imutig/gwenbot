<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sudoku 1v1 - xsgwen</title>
    <link rel="icon"
        href="https://static-cdn.jtvnw.net/jtv_user_pictures/1efe260a-d1d3-4215-9c9f-5a24aea55625-profile_image-70x70.png">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap"
        rel="stylesheet">
    <link rel="stylesheet" href="/css/style.css">
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        .sudoku-container {
            max-width: 600px;
            margin: 0 auto;
        }

        .game-controls {
            display: flex;
            gap: 1rem;
            margin-bottom: 1.5rem;
            flex-wrap: wrap;
        }

        .mode-btn,
        .difficulty-btn {
            padding: 0.6rem 1.25rem;
            border-radius: 12px;
            border: 2px solid var(--border-color);
            background: var(--bg-card);
            color: var(--text-primary);
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .mode-btn.active,
        .difficulty-btn.active {
            background: var(--pink-accent);
            color: white;
            border-color: var(--pink-accent);
        }

        .start-btn {
            padding: 0.75rem 2rem;
            background: linear-gradient(135deg, #9146FF, #7c3aed);
            color: white;
            border: none;
            border-radius: 12px;
            font-weight: 600;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .start-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(145, 70, 255, 0.3);
        }

        .start-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .sudoku-grid {
            display: grid;
            grid-template-columns: repeat(9, 1fr);
            gap: 2px;
            background: var(--text-primary);
            padding: 3px;
            border-radius: 12px;
            margin-bottom: 1.5rem;
        }

        .sudoku-cell {
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            font-weight: 600;
            background: var(--bg-card);
            cursor: pointer;
            transition: all 0.1s;
        }

        .sudoku-cell:hover {
            background: var(--bg-card-hover);
        }

        .sudoku-cell.fixed {
            color: var(--text-muted);
            cursor: default;
        }

        .sudoku-cell.filled {
            color: var(--pink-accent);
        }

        .sudoku-cell.selected {
            background: rgba(var(--pink-accent-rgb), 0.2);
            box-shadow: inset 0 0 0 2px var(--pink-accent);
        }

        .sudoku-cell.error {
            color: #ef4444;
            background: rgba(239, 68, 68, 0.1);
        }

        /* 3x3 box borders */
        .sudoku-cell:nth-child(3n) {
            border-right: 2px solid var(--text-primary);
        }

        .sudoku-cell:nth-child(9n) {
            border-right: none;
        }

        .sudoku-cell:nth-child(n+19):nth-child(-n+27),
        .sudoku-cell:nth-child(n+46):nth-child(-n+54) {
            border-bottom: 2px solid var(--text-primary);
        }

        .number-pad {
            display: grid;
            grid-template-columns: repeat(9, 1fr);
            gap: 0.5rem;
            margin-bottom: 1.5rem;
        }

        .number-btn {
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.25rem;
            font-weight: 600;
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.1s;
        }

        .number-btn:hover {
            background: var(--pink-accent);
            color: white;
        }

        .opponent-section {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 16px;
            padding: 1rem;
            margin-top: 1.5rem;
        }

        .opponent-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.75rem;
        }

        .opponent-name {
            font-weight: 600;
        }

        .opponent-progress {
            color: var(--pink-accent);
            font-weight: 700;
        }

        .opponent-grid {
            display: grid;
            grid-template-columns: repeat(9, 1fr);
            gap: 2px;
            background: var(--border-color);
            padding: 2px;
            border-radius: 8px;
        }

        .opponent-cell {
            aspect-ratio: 1;
            background: var(--bg-input);
            border-radius: 2px;
        }

        .opponent-cell.filled {
            background: var(--pink-accent);
        }

        .queue-section {
            margin-top: 1.5rem;
        }

        .queue-list {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-top: 0.75rem;
        }

        .queue-item {
            padding: 0.5rem 1rem;
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 20px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .queue-item:hover {
            background: var(--pink-accent);
            color: white;
        }

        .random-btn {
            padding: 0.5rem 1rem;
            background: linear-gradient(135deg, #22c55e, #16a34a);
            color: white;
            border: none;
            border-radius: 20px;
            font-weight: 600;
            cursor: pointer;
        }

        .join-btn {
            padding: 0.75rem 2rem;
            background: var(--pink-accent);
            color: white;
            border: none;
            border-radius: 12px;
            font-weight: 600;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .join-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .game-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .timer {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--pink-accent);
        }

        .status-badge {
            padding: 0.4rem 1rem;
            border-radius: 20px;
            font-weight: 600;
            font-size: 0.85rem;
        }

        .status-waiting {
            background: rgba(250, 204, 21, 0.1);
            color: #facc15;
        }

        .status-playing {
            background: rgba(34, 197, 94, 0.1);
            color: #22c55e;
        }

        .status-finished {
            background: rgba(145, 70, 255, 0.1);
            color: #9146FF;
        }

        .winner-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .winner-card {
            background: var(--bg-card);
            border-radius: 24px;
            padding: 3rem;
            text-align: center;
            animation: popIn 0.3s ease-out;
        }

        @keyframes popIn {
            from {
                transform: scale(0.8);
                opacity: 0;
            }

            to {
                transform: scale(1);
                opacity: 1;
            }
        }

        .winner-text {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: 1rem;
        }

        .history-section {
            margin-top: 2rem;
        }

        .history-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 1rem;
            background: var(--bg-card);
            border-radius: 12px;
            margin-bottom: 0.5rem;
        }
    </style>
</head>

<body>
    <!-- Floral Background -->
    <div class="floral-bg">
        <svg class="flower flower-1" viewBox="0 0 100 100">
            <g transform="translate(50,50)">
                <path d="M0,-35 C10,-35 15,-20 0,0 C-15,-20 -10,-35 0,-35" transform="rotate(0)" />
                <path d="M0,-35 C10,-35 15,-20 0,0 C-15,-20 -10,-35 0,-35" transform="rotate(60)" />
                <path d="M0,-35 C10,-35 15,-20 0,0 C-15,-20 -10,-35 0,-35" transform="rotate(120)" />
                <path d="M0,-35 C10,-35 15,-20 0,0 C-15,-20 -10,-35 0,-35" transform="rotate(180)" />
                <path d="M0,-35 C10,-35 15,-20 0,0 C-15,-20 -10,-35 0,-35" transform="rotate(240)" />
                <path d="M0,-35 C10,-35 15,-20 0,0 C-15,-20 -10,-35 0,-35" transform="rotate(300)" />
            </g>
        </svg>
        <svg class="flower flower-2" viewBox="0 0 100 100">
            <g transform="translate(50,50)">
                <path d="M0,-35 C10,-35 15,-20 0,0 C-15,-20 -10,-35 0,-35" transform="rotate(0)" />
                <path d="M0,-35 C10,-35 15,-20 0,0 C-15,-20 -10,-35 0,-35" transform="rotate(60)" />
                <path d="M0,-35 C10,-35 15,-20 0,0 C-15,-20 -10,-35 0,-35" transform="rotate(120)" />
                <path d="M0,-35 C10,-35 15,-20 0,0 C-15,-20 -10,-35 0,-35" transform="rotate(180)" />
                <path d="M0,-35 C10,-35 15,-20 0,0 C-15,-20 -10,-35 0,-35" transform="rotate(240)" />
                <path d="M0,-35 C10,-35 15,-20 0,0 C-15,-20 -10,-35 0,-35" transform="rotate(300)" />
            </g>
        </svg>
    </div>

    <!-- Dynamic Navbar -->
    <div id="navbar-placeholder"></div>

    <!-- Main Content -->
    <main class="main-content">
        <div class="sudoku-container">
            <h1 class="animate-slideIn"
                style="text-align: center; margin-bottom: 1.5rem; display: flex; align-items: center; justify-content: center; gap: 0.5rem;">
                <i data-lucide="grid-3x3" style="color: var(--pink-accent);"></i>
                Sudoku 1v1
            </h1>

            <!-- Loading -->
            <div id="loadingState" style="text-align: center; padding: 3rem;">
                <p style="color: var(--text-muted);">Chargement...</p>
            </div>

            <!-- No Game State (for host) -->
            <div id="noGameState" class="glass-card animate-slideIn" style="padding: 2rem; display: none;">
                <h3 style="margin-bottom: 1rem; display: flex; align-items: center; gap: 0.5rem;">
                    <i data-lucide="play-circle" style="color: var(--pink-accent);"></i>
                    Nouvelle partie
                </h3>

                <div style="margin-bottom: 1rem;">
                    <label style="font-weight: 500; margin-bottom: 0.5rem; display: block;">Mode</label>
                    <div class="game-controls">
                        <button class="mode-btn active" data-mode="solo" onclick="selectMode('solo')">üéÆ Solo</button>
                        <button class="mode-btn" data-mode="multi" onclick="selectMode('multi')">‚öîÔ∏è Multi (1v1)</button>
                    </div>
                </div>

                <div style="margin-bottom: 1.5rem;">
                    <label style="font-weight: 500; margin-bottom: 0.5rem; display: block;">Difficult√©</label>
                    <div class="game-controls">
                        <button class="difficulty-btn" data-diff="easy"
                            onclick="selectDifficulty('easy')">Facile</button>
                        <button class="difficulty-btn active" data-diff="medium"
                            onclick="selectDifficulty('medium')">Moyen</button>
                        <button class="difficulty-btn" data-diff="hard"
                            onclick="selectDifficulty('hard')">Difficile</button>
                    </div>
                </div>

                <button class="start-btn" onclick="createGame()">
                    üöÄ Lancer la partie
                </button>
            </div>

            <!-- Waiting State (for viewers) -->
            <div id="waitingViewerState" class="glass-card animate-slideIn"
                style="padding: 2rem; text-align: center; display: none;">
                <i data-lucide="clock"
                    style="width: 48px; height: 48px; color: var(--pink-accent); margin-bottom: 1rem;"></i>
                <h3 style="margin-bottom: 0.5rem;">Partie en attente</h3>
                <p style="color: var(--text-muted); margin-bottom: 1.5rem;" id="waitingInfo">xsgwen pr√©pare une
                    partie...</p>

                <button id="joinQueueBtn" class="join-btn" onclick="joinQueue()">
                    üôã Je veux jouer !
                </button>
                <p id="queueStatus" style="color: var(--text-muted); margin-top: 1rem; display: none;">
                    Tu es dans la file d'attente...
                </p>
            </div>

            <!-- Waiting State (for host) - Queue view -->
            <div id="waitingHostState" class="glass-card animate-slideIn" style="padding: 2rem; display: none;">
                <div class="game-info">
                    <span class="status-badge status-waiting">‚è≥ En attente</span>
                    <button
                        style="padding: 0.5rem 1rem; background: rgba(239, 68, 68, 0.1); color: #ef4444; border: none; border-radius: 8px; cursor: pointer;"
                        onclick="cancelGame()">
                        Annuler
                    </button>
                </div>

                <h3 style="margin-bottom: 1rem;">Joueurs qui veulent d√©fier :</h3>
                <div id="queueList" class="queue-list">
                    <p style="color: var(--text-muted);">Personne pour l'instant...</p>
                </div>

                <div style="margin-top: 1.5rem; display: flex; gap: 1rem;">
                    <button id="randomBtn" class="random-btn" onclick="selectRandom()" disabled>
                        üé≤ Choisir au hasard
                    </button>
                    <button class="start-btn" onclick="startSolo()"
                        style="background: var(--bg-card); color: var(--text-primary); border: 1px solid var(--border-color);">
                        ‚ñ∂Ô∏è D√©marrer en solo
                    </button>
                </div>
            </div>

            <!-- Playing State -->
            <div id="playingState" class="glass-card animate-slideIn" style="padding: 1.5rem; display: none;">
                <div class="game-info">
                    <span id="gameStatus" class="status-badge status-playing">üéÆ En cours</span>
                    <span class="timer" id="timer">00:00</span>
                </div>

                <!-- Main Grid -->
                <div id="sudokuGrid" class="sudoku-grid"></div>

                <!-- Number Pad -->
                <div class="number-pad">
                    <button class="number-btn" onclick="enterNumber(1)">1</button>
                    <button class="number-btn" onclick="enterNumber(2)">2</button>
                    <button class="number-btn" onclick="enterNumber(3)">3</button>
                    <button class="number-btn" onclick="enterNumber(4)">4</button>
                    <button class="number-btn" onclick="enterNumber(5)">5</button>
                    <button class="number-btn" onclick="enterNumber(6)">6</button>
                    <button class="number-btn" onclick="enterNumber(7)">7</button>
                    <button class="number-btn" onclick="enterNumber(8)">8</button>
                    <button class="number-btn" onclick="enterNumber(9)">9</button>
                </div>
                <button class="number-btn" onclick="enterNumber(0)"
                    style="width: 100%; aspect-ratio: auto; padding: 0.75rem;">
                    ‚å´ Effacer
                </button>

                <!-- Opponent Progress -->
                <div id="opponentSection" class="opponent-section" style="display: none;">
                    <div class="opponent-header">
                        <span class="opponent-name" id="opponentName">Adversaire</span>
                        <span class="opponent-progress" id="opponentProgress">0/81</span>
                    </div>
                    <div id="opponentGrid" class="opponent-grid"></div>
                </div>
            </div>

            <!-- Winner Overlay -->
            <div id="winnerOverlay" class="winner-overlay" style="display: none;">
                <div class="winner-card">
                    <div style="font-size: 4rem; margin-bottom: 1rem;">üèÜ</div>
                    <div class="winner-text" id="winnerText">Victoire !</div>
                    <p style="color: var(--text-muted); margin-bottom: 1.5rem;" id="winnerInfo"></p>
                    <button class="start-btn" onclick="closeWinner()">Fermer</button>
                </div>
            </div>

            <!-- History Section -->
            <div id="historySection" class="history-section" style="display: none;">
                <h3 style="margin-bottom: 1rem;">üìú Historique des parties</h3>
                <div id="historyList"></div>
            </div>
        </div>
    </main>

    <footer class="footer">
        <p>Powered by <a href="#">GwenBot</a></p>
    </footer>

    <script src="/js/main.js"></script>
    <script src="/js/navbar.js"></script>
    <script>
        // Game state
        let ws = null;
        let sessionId = null;
        let user = null;
        let gameState = null;
        let selectedCell = null;
        let selectedMode = 'solo';
        let selectedDifficulty = 'medium';
        let timerInterval = null;
        let startTime = null;

        // Initialize
        async function init() {
            // Check auth
            try {
                const res = await fetch('/api/auth/user');
                const data = await res.json();

                if (data.authenticated) {
                    user = data.user;
                    sessionId = Math.random().toString(36).substring(2);
                }
            } catch (e) {
                console.error('Auth check error:', e);
            }

            // Connect WebSocket
            connectWebSocket();

            // Load history
            loadHistory();

            lucide.createIcons();
        }

        function connectWebSocket() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            ws = new WebSocket(`${protocol}//${window.location.host}/ws/sudoku`);

            ws.onopen = () => {
                console.log('üß© Connected to Sudoku WebSocket');
                // Send auth
                ws.send(JSON.stringify({
                    type: 'auth',
                    sessionId,
                    user
                }));
            };

            ws.onmessage = (event) => {
                const message = JSON.parse(event.data);
                handleServerMessage(message);
            };

            ws.onclose = () => {
                console.log('WebSocket closed, reconnecting...');
                setTimeout(connectWebSocket, 3000);
            };
        }

        function handleServerMessage(message) {
            switch (message.type) {
                case 'game_state':
                    updateGameState(message.payload);
                    break;
                case 'queue_update':
                    updateQueue(message.payload);
                    break;
                case 'progress_update':
                    updateProgress(message.payload);
                    break;
            }
        }

        function updateGameState(state) {
            gameState = state;

            document.getElementById('loadingState').style.display = 'none';
            document.getElementById('noGameState').style.display = 'none';
            document.getElementById('waitingViewerState').style.display = 'none';
            document.getElementById('waitingHostState').style.display = 'none';
            document.getElementById('playingState').style.display = 'none';
            document.getElementById('historySection').style.display = 'none';

            if (!state.active) {
                // No game active
                if (user && user.display_name.toLowerCase() === 'xsgwen') {
                    document.getElementById('noGameState').style.display = 'block';
                } else {
                    document.getElementById('historySection').style.display = 'block';
                }
                stopTimer();
                return;
            }

            if (state.status === 'waiting') {
                if (state.isHost) {
                    document.getElementById('waitingHostState').style.display = 'block';
                    updateQueue(state.queue);
                } else {
                    document.getElementById('waitingViewerState').style.display = 'block';
                    document.getElementById('waitingInfo').textContent =
                        `Mode: ${state.mode === 'multi' ? 'Multi (1v1)' : 'Solo'} | Difficult√©: ${state.difficulty}`;

                    if (state.mode === 'multi') {
                        document.getElementById('joinQueueBtn').style.display = 'block';
                    } else {
                        document.getElementById('joinQueueBtn').style.display = 'none';
                    }
                }
            } else if (state.status === 'playing') {
                if (state.isPlayer) {
                    document.getElementById('playingState').style.display = 'block';
                    renderGrid(state.puzzle, state.myProgress);

                    if (state.mode === 'multi' && state.opponentName) {
                        document.getElementById('opponentSection').style.display = 'block';
                        document.getElementById('opponentName').textContent = state.opponentName;
                        updateOpponentGrid(state.opponentCells);
                    }

                    startTimer(state.startedAt);
                } else {
                    // Spectator
                    document.getElementById('waitingViewerState').style.display = 'block';
                    document.getElementById('waitingInfo').textContent = 'Partie en cours...';
                    document.getElementById('joinQueueBtn').style.display = 'none';
                }
            } else if (state.status === 'finished') {
                showWinner(state.winner);
            }

            lucide.createIcons();
        }

        function renderGrid(puzzle, progress) {
            const grid = document.getElementById('sudokuGrid');
            grid.innerHTML = '';

            for (let i = 0; i < 81; i++) {
                const cell = document.createElement('div');
                cell.className = 'sudoku-cell';
                cell.dataset.index = i;

                if (puzzle[i] !== '0') {
                    cell.textContent = puzzle[i];
                    cell.classList.add('fixed');
                } else if (progress && progress[i] !== '0') {
                    cell.textContent = progress[i];
                    cell.classList.add('filled');
                }

                cell.onclick = () => selectCellAt(i);
                grid.appendChild(cell);
            }
        }

        function selectCellAt(index) {
            if (!gameState || gameState.status !== 'playing') return;
            if (gameState.puzzle[index] !== '0') return; // Can't edit fixed cells

            // Deselect previous
            document.querySelectorAll('.sudoku-cell.selected').forEach(c => c.classList.remove('selected'));

            selectedCell = index;
            document.querySelector(`.sudoku-cell[data-index="${index}"]`).classList.add('selected');
        }

        function enterNumber(num) {
            if (selectedCell === null || !gameState || gameState.status !== 'playing') return;
            if (gameState.puzzle[selectedCell] !== '0') return;

            // Update local state
            const cell = document.querySelector(`.sudoku-cell[data-index="${selectedCell}"]`);
            cell.textContent = num === 0 ? '' : num;
            cell.classList.toggle('filled', num !== 0);
            cell.classList.remove('error');

            // Send to server
            ws.send(JSON.stringify({
                type: 'cell_update',
                payload: { index: selectedCell, value: num },
                sessionId,
                user
            }));
        }

        function updateQueue(queue) {
            const list = document.getElementById('queueList');
            const randomBtn = document.getElementById('randomBtn');

            if (!queue || queue.length === 0) {
                list.innerHTML = '<p style="color: var(--text-muted);">Personne pour l\'instant...</p>';
                randomBtn.disabled = true;
            } else {
                list.innerHTML = queue.map(q =>
                    `<button class="queue-item" onclick="selectChallenger('${q.username}')">${q.username}</button>`
                ).join('');
                randomBtn.disabled = false;
            }
        }

        function updateProgress(data) {
            if (data.myProgress && gameState) {
                renderGrid(gameState.puzzle, data.myProgress);
            }
            if (data.opponentCells !== undefined) {
                updateOpponentGrid(data.opponentCells);
            }
        }

        function updateOpponentGrid(cellsFilled) {
            document.getElementById('opponentProgress').textContent = `${cellsFilled}/81`;

            const grid = document.getElementById('opponentGrid');
            grid.innerHTML = '';

            // Just show filled/empty state without numbers
            for (let i = 0; i < 81; i++) {
                const cell = document.createElement('div');
                cell.className = 'opponent-cell';
                // Approximate which cells are filled based on count
                if (i < cellsFilled) {
                    cell.classList.add('filled');
                }
                grid.appendChild(cell);
            }
        }

        function selectMode(mode) {
            selectedMode = mode;
            document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
            document.querySelector(`.mode-btn[data-mode="${mode}"]`).classList.add('active');
        }

        function selectDifficulty(diff) {
            selectedDifficulty = diff;
            document.querySelectorAll('.difficulty-btn').forEach(b => b.classList.remove('active'));
            document.querySelector(`.difficulty-btn[data-diff="${diff}"]`).classList.add('active');
        }

        async function createGame() {
            try {
                const res = await fetch('/api/sudoku/create', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ mode: selectedMode, difficulty: selectedDifficulty })
                });
                const data = await res.json();
                if (!data.success) {
                    alert('Erreur: ' + (data.error || 'Impossible de cr√©er la partie'));
                }
            } catch (e) {
                console.error('Create game error:', e);
            }
        }

        async function cancelGame() {
            if (!confirm('Annuler la partie ?')) return;
            try {
                await fetch('/api/sudoku/cancel', { method: 'POST' });
            } catch (e) {
                console.error('Cancel error:', e);
            }
        }

        function joinQueue() {
            if (!user) {
                window.location.href = '/auth/login';
                return;
            }
            ws.send(JSON.stringify({
                type: 'join_queue',
                sessionId,
                user
            }));
            document.getElementById('joinQueueBtn').disabled = true;
            document.getElementById('queueStatus').style.display = 'block';
        }

        function selectChallenger(username) {
            ws.send(JSON.stringify({
                type: 'select_challenger',
                payload: { username },
                sessionId,
                user
            }));
        }

        function selectRandom() {
            ws.send(JSON.stringify({
                type: 'random_challenger',
                sessionId,
                user
            }));
        }

        function startSolo() {
            ws.send(JSON.stringify({
                type: 'start_solo',
                sessionId,
                user
            }));
        }

        function startTimer(startedAt) {
            if (timerInterval) clearInterval(timerInterval);
            startTime = new Date(startedAt);

            timerInterval = setInterval(() => {
                const elapsed = Math.floor((Date.now() - startTime.getTime()) / 1000);
                const mins = Math.floor(elapsed / 60).toString().padStart(2, '0');
                const secs = (elapsed % 60).toString().padStart(2, '0');
                document.getElementById('timer').textContent = `${mins}:${secs}`;
            }, 1000);
        }

        function stopTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
        }

        function showWinner(winnerName) {
            document.getElementById('winnerOverlay').style.display = 'flex';
            const isMe = user && winnerName.toLowerCase() === user.display_name.toLowerCase();
            document.getElementById('winnerText').textContent = isMe ? 'üéâ Tu as gagn√© !' : `${winnerName} a gagn√© !`;
            document.getElementById('winnerInfo').textContent = isMe ? 'F√©licitations !' : 'Bien jou√© quand m√™me !';
        }

        function closeWinner() {
            document.getElementById('winnerOverlay').style.display = 'none';
        }

        async function loadHistory() {
            try {
                const res = await fetch('/api/sudoku/history');
                const data = await res.json();

                const list = document.getElementById('historyList');
                if (!data.history || data.history.length === 0) {
                    list.innerHTML = '<p style="color: var(--text-muted);">Aucune partie pour l\'instant</p>';
                    return;
                }

                list.innerHTML = data.history.map(h => {
                    const date = new Date(h.created_at).toLocaleDateString('fr-FR');
                    return `
                        <div class="history-item">
                            <span>${h.mode === 'multi' ? '‚öîÔ∏è' : 'üéÆ'} ${h.difficulty} ‚Ä¢ ${date}</span>
                            <span style="color: var(--pink-accent); font-weight: 600;">${h.winner_name ? `üèÜ ${h.winner_name}` : '-'}</span>
                        </div>
                    `;
                }).join('');
            } catch (e) {
                console.error('Load history error:', e);
            }
        }

        init();
    </script>
</body>

</html>